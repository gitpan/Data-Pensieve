.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Data::Pensieve 3"
.TH Data::Pensieve 3 "2012-12-19" "perl v5.14.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Data::Pensieve \- Simple tool for interacting with revisioned data
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Data::Pensieve;
\&    
\&    my $pensieve = Data::Pensieve\->new(
\&        revision_rs      => $c\->model(\*(AqDB::Revision\*(Aq),
\&        revision_data_rs => $c\->model(\*(AqDB::RevisionData\*(Aq),
\&        definitions      => {
\&            lolcats => [ qw/name saying picture/ ],
\&        },
\&    );
\&    
\&    $pensieve\->store_revision(
\&        lolcats => 1,
\&        {
\&            # data
\&            name    => \*(Aqlazy lolcat\*(Aq,
\&            saying  => \*(Aqi cannot brian today. i have the dumb\*(Aq,
\&            picture => \*(Aqlazycat.png\*(Aq,
\&        },
\&        {
\&            # change metadata
\&            modified_by => \*(Aqwaffle wizard\*(Aq,
\&        },
\&    );
\&
\&    # oops! a typo! time to denote a change.
\&    $pensieve\->store_revision(
\&        lolcats => 1,
\&        {
\&            # data
\&            saying => \*(Aqi cannot brain today. i have the dumb\*(Aq,
\&        },
\&        {
\&            # change metadata
\&            modified_by => \*(Aqassistant regional manager\*(Aq,
\&        },
\&    );
\&    
\&    my @revisions = $pensieve\->get_revisions(lolcats => 1);
\&    
\&    my ($rev1, $rev2) = @revisions;
\&
\&    my $comparison = $pensieve\->compare_revisions($rev1, $rev2);
\&    # {
\&    #   saying => [
\&    #       \*(Aqi cannot brian today. i have the dumb\*(Aq,
\&    #       \*(Aqi cannot brain today. i have the dumb\*(Aq
\&    #   ]
\&    # }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\*(L"I use the Pensieve. One simply siphons the excess thoughts from one's mind, pours them into the basin, and examines them at one's leisure. It becomes easier to spot patterns and links, you understand, when they are in this form.\*(R" \- Albus Dumbledore
.PP
In the world of Harry Potter, a Pensieve is a magical device that allows a wizard to store and review his or her thoughts. Data::Pensieve serves a similar purpose for Perl applications, allowing you to easily record revision histories and analyze differences between revisions.
.PP
Data::Pensieve uses a DBIx::Class backend to store revision data.
.SH "METHODS"
.IX Header "METHODS"
.SS "\fInew()\fP"
.IX Subsection "new()"
Returns a new Data::Pensieve object. Takes the following required parameters.
.IP "\(bu" 4
\&\fBdefinitions\fR
.Sp
A hash reference, where the keys are the names of groups of data and the values are array references of the expected columns.
.Sp
For instance:
.Sp
.Vb 6
\&    # {
\&    #    cats       => [ qw/ name favorite_toy           / ],
\&    #    people     => [ qw/ name occupation             / ],
\&    #    food       => [ qw/ name calories               / ],
\&    #    japh       => [ qw/ cpan_name num_yapcs_attended /],
\&    # }
.Ve
.IP "\(bu" 4
\&\fBrevision_rs\fR
.Sp
A DBIx::Class::ResultSet representing the revision table, which must have the following schema:
.Sp
.Vb 5
\&    revision_id int auto_increment primary key,
\&    grouping    varchar(255),
\&    identifier  varchar(255),
\&    recorded    datetime,
\&    metadata    blob
.Ve
.IP "\(bu" 4
\&\fBrevision_data_rs\fR
.Sp
A DBIx::Class::ResultSet reprensenting the revision data table, which must have the following schema:
.Sp
.Vb 4
\&    revision_data_id int auto_increment primary key,
\&    revision_id      int,
\&    datum            varchar(255),
\&    datum_value      blob
.Ve
.SS "\fIstore_revision()\fP"
.IX Subsection "store_revision()"
Given a grouping, item, hash reference of data, and optional hash reference of metadata related to this change, stores a change.
.SS "\fIget_revisions()\fP"
.IX Subsection "get_revisions()"
Given a grouping and item number, returns all associated revisions.
.SS "\fIget_last_revision()\fP"
.IX Subsection "get_last_revision()"
Given a grouping and item number, returns the last revision.
.SS "\fIcompare_revisions()\fP"
.IX Subsection "compare_revisions()"
Given two Data::Pensieve::Revision objects, returns a hash reference, keyed by column name, containing array references of the prior and current version of all changed data between the two provided revisions.
.SS "\fIdiff_revisions()\fP"
.IX Subsection "diff_revisions()"
Same as \fIcompare_revisions()\fR, but returns a diff between the two values instead of an array reference.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
Data::Pensieve is intended as a quick & dirty, plug & play way to easily manage revisioned data.
.PP
If you're looking to do something more substantial, you probably want to consider journaling your data at the database level \*(-- check out DBIx::Class::AuditLog or DBIx::Class::Journal.
.SH "DEPENDENCIES"
.IX Header "DEPENDENCIES"
Carp, DateTime, DateTime::Format::MySQL, DBIx::Class, List::Util, List::MoreUtils, Moose, Storable, Text::Diff
.SH "AUTHORS"
.IX Header "AUTHORS"
Michael Aquilina <aquilina@cpan.org>
.PP
Developed for Grant Street Group's Testafy (<http://testafy.com>)
